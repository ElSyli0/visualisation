<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>INFOVIS</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.42.2/mapbox-gl.js'></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
   integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
   crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.42.2/mapbox-gl.css' rel='stylesheet'></link>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin=""/>
    <link rel="stylesheet" href="/static/css/style.css">
    <style type="text/css">
        /* BAR CHART */
        /*
        .bar {
            fill: steelblue;   
        }
        .axis text {
            font: 10px sans-serif;   
        }
        .axis path {
            fill: none;   
            stroke: #000000;  
        }
        #plot_facts {
            width: 700px;   
            height: 500px; 
        }
        button.next_fact, button.prev_fact, button.next_csq, button.prev_csq {
            border-radius: 5px;
            color: white;
            background-color: navy;
            font-family: arial, sans-serif;
            height: 30px;
            text-decoration: none;
            width: 70px;
            display: block;
        }
        button.next_fact:hover, button.prev_fact:hover, button.next_csq:hover, button.prev_csq:hover{
            background-color: blue;
        }
        */
        #map { 
				width: 1000px;   /* Dimensions of the map element */
				height: 600px;
			}

			/* CSS code for the elements that have the class prefecture */

			.country {
				cursor: default;   /* Changes the look of the cursor when it hovers the element */
				fill: #638abd;   /* Color */
				fill-opacity: 0.6;   /* Transparency, from 0 (invisible) to 1 (opaque) */
				stroke: #004d60;   /* Border color */
				stroke-width: 1;   /* Border width in pixels */
			}

			/* CSS code for the elements that have the class selected_prefecture */

			.selected_country {
				cursor: default;   /* Changes the look of the cursor when it hovers the element */
				fill: #ed5a3b;   /* Color */
				fill-opacity: 0.8;   /* Transparency, from 0 (invisible) to 1 (opaque) */
				stroke: #654321;   /* Border color */
				stroke-width: 1;   /* Border width in pixels */
			}

			/* CSS code for the element that has the id polygons_container */

			#polygons_container {
				position: absolute;
				width: 100%;   /* Width of the element is 100% of the width of its parent */
				height: 100%;   /* Height of the element is 100% of the width of its parent */
			}

    </style>
</head>
<body>

    <script type="text/javascript">
        // 
        function countInstance(val, x){
            count = 0;
            for (let i = 0; i < x.length; i++) {
                if(x[i] == val) count ++;
            }
            return count;
        }
        //
        function drawBartChart(data){
            // Vide le conteneur svg
            document.getElementById("plot_facts").innerHTML = "";
            // Dimension
            let margin = {top: 20, right: 20, bottom: 70, left: 60};
            let width = document.getElementById("plot_facts").getBoundingClientRect().width - margin.left - margin.right;
		    let height = document.getElementById("plot_facts").getBoundingClientRect().height - margin.top - margin.bottom;
            // Gestion de l'axe des abscisses
            let x = d3.scaleBand()
			    .range([0, width], .1);
            x.domain(data.map(function(d){   // data.map(function) returns an array with the same number of entries that the dataset has. For each entry (the parameter d refers to one entry) of the dataset, the transformation defined inside function is applied. The result is the corresponding entry in the array resulting from data.map
			    return d.intensity;   // The transformation consists of returning d.agent, that is, the agent in the entry d. Thus, it consists of scrapping off the sales amount to keep only the agent's name
		    }));
            // Gestion de l'axe des ordonnées
            let y = d3.scaleLinear()
			    .range([height, 0]);
            y.domain([0, d3.max(data, function(d){   // This returns the maximum (d3.max) number encountered after keeping only the sales from the dataset
                return d.nbr;
            })]);
            // Affichage des abscisses
            let xAxis = d3.axisBottom(x)
            let yAxis = d3.axisLeft(y)
            // Affichage des éléments
            let chart = d3.select("#plot_facts")
			    .append("g")   // A g element is appended to the barchart svg. It will contain all the graphical elements of the visualization
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")"); 
            chart.append("g")
                .attr("class", "x axis")   // The classes x and axis are assigned to the g element. Thus, the g element has the styles defined for x and axis classes in the CSS code
                .attr("transform", "translate(0," + height + ")")   // The origin of the bar chart is at the bottom left, but the origin of a SVG element is its top left corner. Thus, the x axis needs to be moved down by height pixels in order to appear at the bottom of the chart
                .call(xAxis)   // Define that it is the x axis in the g element
                .selectAll("text")   // A selection is made to gather all the text elements in the x axis (that is, the ticks labels)
				    .style("text-anchor", "middle")   // The text elements are attached at the middle of their tick
				    .attr("dy", "0.5em");
            chart.append("g")
			    .attr("class", "y axis")   // The classes y and axis are assigned to the g element. Thus, the g element has the styles defined for y and axis classes in the CSS code
			    .call(yAxis);   // Define that it is the y axis in the g element
            //
            chart.selectAll(".bar")
                .data(data)   // The dataset data is assigned. Elements with the class bar will be created accordingly
                .enter().append("rect")   // .enter() defines new data elements for which a visual element counterpart (in the present case, a rectangle) needs to be created. The code after .enter() will be executed on each of these visual elements (hence, once per entry in the dataset)
                    .attr("class", "bar")   // The rectangles have the class bar
                    .attr("x", function(d){   // The x position of the rectangle is determined by the agent to which the rectangle corresponds
                        return x(d.intensity);
                    })
                    .attr("y", function(d){
                        return y(d.nbr);   // By default, the bars are aligned to the top of the chart (remember, the origin of a SVG element is at its top left corner). y(d.sales) is the size of the gap between the bar aligned to the top and the x axis
                    })
                    .attr("height", function(d){   // The height of each rectangle is computed accordingly to the sales
                        return height - y(d.nbr);
                    })
                    .attr("width", x.bandwidth())   // The width of a bar depends on the space allocated to the bars on the x axis
            // Label pour abscisses
            chart.append("text")						 
                .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.top + 30) + ")")   // The label is translated rightwards by half the width of the chart (thus, it will appear at the middle)
                .style("text-anchor", "middle")   // The label is at the middle (without this line, it would be the origin of the text element that would be at the middle of the chart. The label would not be exactly centered)
                .text("Intensité");   // Label
            // Label pour ordonnées
            chart.append("text")
                .attr("transform", "rotate(-90)")   // The label is rotated by -90 degrees in order to be written along the y axis
                .attr("y", 0 - margin.left)   // The element was rotated by -90 degrees -> attention to the coordinates to translate
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")   
                .style("text-anchor", "middle")   // The label is at the middle (without this line, it would be the origin of the text element that would be at the middle of the chart. The label would not be exactly centered)
                .text("Occurence");   // Label
        }

        // function to draw plot about the earthquake
        function plotEvolutionFrequencyForEarthquakes(){
            d3.json("/getEarthquake")
                .then(function(data){
                    var x = [];
                    for (let i = 0; i < data.length; i++) {
                        const element = data[i];
                        var tmp = element.intensity;
                        if(tmp){
                            x.push(tmp);
                        }
                    }
                    // Histogram
                    var max_x = d3.max(x);
                    var min_x = d3.min(x);
                    var y = [];
                    for (let i = min_x; i <= max_x; i++) {
                        var tmp = {};
                        tmp["intensity"] = i;
                        tmp["nbr"] = countInstance(i, x)
                        y.push(tmp);
                    }
                    drawBartChart(y);
                });
        }

        
        // Tout ce qui sera dans cette fonction sera possible une fois que la page sera chargée
        $(document).ready(function(){
            plotEvolutionFrequencyForEarthquakes();
            $("button.next_fact").click(function(){
                var id = $(this).attr("id").replace("next_facts_", "");
                var tmp = (id)%3;
                alert(tmp);
                switch (tmp) {
                    case 1:
                        alert("Affichage graph de type 2")
                        $(this).attr("id", )
                        break;
                    case 2:
                        alert("Affichage graph de type 3")
                        break;
                    case 0:
                        alert("Affichage graph de type 1")
                    default:
                        break;
                }
                id *= 1;
                id++;
                id +=""
                var txt = "next_facts_"+id;
                $(this).attr("id", txt);
            });
            $("button.prev_fact").click(function(){
                var id = $(this).attr("id").replace("prev_facts_", "");
                var tmp = (id)%3;
                alert(tmp);
                switch (tmp) {
                    case 1:
                        alert("Affichage graph de type 2")
                        $(this).attr("id", )
                        break;
                    case 2:
                        alert("Affichage graph de type 3")
                        break;
                    case 0:
                        alert("Affichage graph de type 1")
                    default:
                        break;
                }
                id *= 1;
                id++;
                id +=""
                var txt = "prev_facts_"+id;
                $(this).attr("id", txt);
            });
            $("button.next_csq").click(function(){
                var id = $(this).attr("id").replace("next_csq_", "");
                var tmp = (id)%3;
                alert(tmp);
                switch (tmp) {
                    case 1:
                        alert("Affichage graph de type 2")
                        $(this).attr("id", )
                        break;
                    case 2:
                        alert("Affichage graph de type 3")
                        break;
                    case 0:
                        alert("Affichage graph de type 1")
                    default:
                        break;
                }
                id *= 1;
                id++;
                id +=""
                var txt = "next_csq_"+id;
                $(this).attr("id", txt);
            });
            $("button.prev_csq").click(function(){
                var id = $(this).attr("id").replace("prev_csq_", "");
                var tmp = (id)%3;
                alert(tmp);
                switch (tmp) {
                    case 1:
                        alert("Affichage graph de type 2")
                        $(this).attr("id", )
                        break;
                    case 2:
                        alert("Affichage graph de type 3")
                        break;
                    case 0:
                        alert("Affichage graph de type 1")
                    default:
                        break;
                }
                id *= 1;
                id++;
                id += ""
                var txt = "prev_csq_"+id;
                $(this).attr("id", txt);
            });
        })

    </script>

    <h1>Où (ne pas) aller dans le monde ?</h1>

    <div id="map"></div>  <!-- Working example - Map with points -->
    <div id="buttons_container">
        <button id="Continents" class="beautiful_button">Continents</button>
        <button id="Countries" class="beautiful_button">Countries</button>
        <button id="Plates" class="beautiful_button">Plates</button>
        <button id="Count_Cont" class="beautiful_button">Count_Cont</button>
    </div>
    <div class="facts">
        <svg id="plot_facts"></svg>
        <div class="nav_btn">
            <button class="next_fact" id="next_facts_1">&rarr;</button>
            <button class="prev_fact" id="prev_facts_1">&larr;</button>  
        </div>
    </div>
    

    <div class="csq">
        <svg id="plot_csq"></svg>
        <div class="nav_btn">
            <button class="next_csq" id="next_csq_1">&rarr;</button>
            <button class="prev_csq" id="prev_csq_1">&larr;</button>  
        </div>
    </div>
</body>
</html>

<script type="text/javascript">
    /*
    // Access Token
    mapboxgl.accessToken = "pk.eyJ1IjoiZWxzeWxpMCIsImEiOiJja3cyNmpvY3kxc2txMm9sY21jeGVkYTRkIn0.rn01oVBCWrwWDU6CWLTt_g";
    // Nouvelle instance Map()
    const map = new mapboxgl.Map({
        container : "map",
        style: "mapbox://styles/mapbox/light-v9",
        center: [4.35, 50.85],
        zoom : 1
    });
    // Ajout des outils de contrôles
    map.addControl(new mapboxgl.NavigationControl({
        position:"top-left"
    }))
    // Création du conteneur
    const container = map.getCanvasContainer()
    console.log(container)
    const svg = d3.select(container)
        .append("svg")
            .attr("id", "polygons_container");
    // Création du chemin pour la projection des polygones
    let test = d3.geoPath();
    let path = d3.geoPath().projection(d3.geoTransform({point: projectPoint}));
    function projectPoint(lon, lat) {
		let point = map.project(new mapboxgl.LngLat(lon, lat));
		this.stream.point(point.x, point.y);
	}
    d3.json("/getContinents")
        .then(function(continents){
            d3.json("/getCountries")
                .then(function(countries){
                    d3.json("/getTect")
                        .then(function(tect){
                            // Now we can work here !
                            console.log(continents);
                            console.log(countries);
                            console.log(tect);
                            drawPolygons(countries.features)
                            // function
                            function drawPolygons(polygons){
                                document.getElementById("polygons_container").innerHTML = "";
                                // zones is the selection holding the polygons
                                let zones = svg.selectAll("path")
                                    .data(polygons);
                                // For each polygon, a path is appended
                                zones.enter().append("path")
                                    .attr("class", "country")   // The appended path have the class prefecture
                                    .on("mouseover", function(d) {
                                        d3.select(this).attr("class", "selected_country");
                                    })                  
                                    .on("mouseout", function(d) {
                                        d3.select(this).attr("class", "country");
                                    })
                                    .append("title")   // A title is added to the path (when the mouse goes over a path, some text will show)
                                        .text(function(d){   // Text of the mouseover title
                                            return d.properties.name;   // The text displayed for a path is the name of the prefecture it represents
                                        });
                                // This function renders the polygons on the map. Basically, it handles the projection of every polygon
                                function render(){
                                    // Remember that zones is a selection of polygons. The .attr("d") is executed once for each path in zones
                                    zones
                                        .attr("d", path)
                                        
                                }
                                // render() is called when the event viewreset of the map is triggered
                                // viewreset means that the content of the layer needs to be redrawn (e.g. zoom)
                                map.on("viewreset", render);
                                // render() is also called when the map is moved (navigation without zoom)
                                map.on("move", render);
                                // render() is called once for initial placement of the polygons
                                render();
                            }
                        });
                });
        });
        */
</script>

<script type="text/javascript">
    // Initialisation
    mapboxgl.accessToken = "pk.eyJ1IjoiZWxzeWxpMCIsImEiOiJja3cyNmpvY3kxc2txMm9sY21jeGVkYTRkIn0.rn01oVBCWrwWDU6CWLTt_g";
    var map = new mapboxgl.Map({
        container : "map",
        style: "mapbox://styles/mapbox/light-v9",
        center: [4.35, 50.85],
        zoom : 1
    });
    var container = map.getCanvasContainer();
    var svg = d3
        .select(container)
        .append("svg")
        .attr("width", "1000px")
        .attr("height", "600px")
        .style("position", "absolute")
        .style("z-index", 2)
        .attr("id", "polygons_container");
    // Fonction de projection pour communication entre mapbox et d3
    function projection(d){
        return map.project(new mapboxgl.LngLat(d[0], d[1]))
    }
    // Load data
    d3.json("/getTect")
        .then(function(tect){
            console.log(tect);
            var poly = svg
                .selectAll("poly")
                .data(tect)
                .enter()
                .append("")
        });

</script>